<chapter xml:id="hbrunlevels-25516">
<title>Managing Services (Overview)</title>
<para>This chapter provides an overview of the Service Management Facility
(SMF). In addition, information that is related to run levels is provided.
<indexterm><primary>SMF</primary><secondary>overview</secondary></indexterm>
<indexterm><primary>service management facility</primary><see>SMF</see></indexterm>
<indexterm><primary>new features</primary><secondary>SMF</secondary></indexterm>
<indexterm><primary>service management facility</primary><see>SMF</see></indexterm>
</para>
<para>This is a list of the overview information in this chapter.</para>
<itemizedlist>
	<listitem><para><xref linkend="dzhgy" /></para></listitem>
	<listitem><para><xref linkend="dzhid" /></para></listitem>
	<listitem><para><xref linkend="dzhjy" /></para></listitem>
	<listitem><para><xref linkend="dzhna" /></para></listitem>
	<listitem><para><xref linkend="dzhkf" /></para></listitem>
	<listitem><para><xref linkend="hbrunlevels-13026" /></para></listitem>
	<listitem><para><xref linkend="hbrunlevels-12863" /></para></listitem>
</itemizedlist>
<para>For information on the procedures associated with SMF, see <xref linkend="eqbrp" />. For information on
the procedures associated with run levels, see <xref linkend="etesg" />.</para>
<sect1 xml:id="dzhgy"><title>Introduction to SMF</title><itemizedlist><para>SMF provides an infrastructure that augments the traditional UNIX start-up
scripts, <command>init</command> run levels, and configuration files. SMF
provides the following functions:</para><listitem><para>Automatically restarts failed services in dependency order,
whether they failed as the result of administrator error, software bug, or
 were affected by an uncorrectable hardware error. The dependency order is
defined by dependency statements.</para>
</listitem><listitem><para>Makes services objects that can be viewed, with the new <command>svcs</command> command, and managed, with <command>svcadm</command> and <command>svccfg</command> commands. You can also view the relationships between services
and processes using <command>svcs</command> <option>p</option>, for both SMF
services and legacy <filename>init.d</filename> scripts.</para>
</listitem><listitem><para>Makes it easy to backup, restore, and undo changes to services
by taking automatic snapshots of service configurations.</para>
</listitem><listitem><para>Makes it easy to debug and ask questions about services by
providing an explanation of why a service isn't running by using <command>svcs</command> <option>x</option>. Also, this process is eased by individual and persistent log files
for each service.</para>
</listitem><listitem><para>Allows for services to be enabled and disabled using <command>svcadm</command>. These changes can persist through upgrades and reboots. If the <option>t</option> option is used, the changes are temporary.</para>
</listitem><listitem><para>Enhances the ability of administrators to securely delegate
tasks to non-root users, including the ability to modify properties and enable,
disable, or restart services on the system.</para>
</listitem><listitem><para>Boots faster on large systems by starting services in parallel
according to the dependencies of the services. The opposite process occurs
during shutdown.</para>
</listitem><listitem><para>Allows you to customize the boot console output to either
be as quiet as possible, which is the default, or to be verbose by using <command>boot</command> <option>m</option> <option role="nodash">verbose</option>.</para>
</listitem><listitem><para>Preserves compatibility with existing administrative practices
wherever possible.  For example, most customer and ISV-supplied rc scripts
still work as usual.</para>
</listitem>
</itemizedlist><para><indexterm><primary>dependency statements (SMF)</primary><secondary>description</secondary></indexterm><emphasis>Dependency statements</emphasis> define
the relationships between services. These relationships can be used to provide
precise fault containment by restarting only those services that are directly
affected by a fault, rather than restarting all of the services. Another advantage
of dependency statements is that the statements allow for scalable and reproducible
initialization processes. In addition, by defining all of the dependencies,
you can take advantage of modern, highly parallel machines, because all independent
services can be started in parallel.</para><para><indexterm><primary>restarters (SMF)</primary><secondary>description</secondary></indexterm>SMF  defines a set of actions that can be invoked on a service
by an administrator. These actions include enable, disable,  refresh, restart,
and maintain. Each service is managed by a service restarter which carries
out the administrative actions. In general, the restarters carry out actions
by executing methods for a service. Methods for each service are defined in
the service configuration repository. These methods allow the restarter to
move the service from one state to another state.</para><para><indexterm><primary>repository (SMF)</primary><secondary>description</secondary></indexterm>The service configuration repository provides a per-service snapshot
at the time that each service is successfully started so that fallback is
possible. In addition, the repository provides a consistent and persistent
way to enable or disable a service, as well as a consistent view of service
state. This capability helps you debug service configuration problems.</para>
</sect1><sect1 xml:id="feosq"><title>Changes in Behavior When Using SMF</title><para>Most of the features that are provided by SMF happen behind the scenes,
so users are not aware of them. Other features are accessed by new commands.
Here is a list of the behavior changes that are most visible.</para><itemizedlist><listitem><para>The boot process creates many fewer messages now. Services
do not display a message by default when they are started. All of the information
that was provided by the boot messages can now be found in a log file for
each service that is in <filename>/var/svc/log</filename>. You can use the <command>svcs</command> command to help diagnose boot problems. In addition, you can
use the <option>v</option> option to the <command>boot</command> command,
which generates a message when each service is started during the boot process.</para>
</listitem><listitem><para>Since services are automatically restarted if possible, it
may seem that a process refuses to die. If the service is defective, the service
will be placed in maintenance mode, but normally a service is restarted if
the process for the service is killed. The <command>svcadm</command> command
should be used to stop the processes of any SMF service that should not be
running.</para>
</listitem><listitem><para>Many of the scripts in <filename>/etc/init.d</filename> and
/etc/rc*.d have been removed. The scripts are no longer needed to enable or
disable a service. Entries from <filename>/etc/inittab</filename> have also
been removed, so that the services can be administered using SMF. Scripts
and <filename>inittab</filename> entries that are provided by an ISV or are
locally developed will continue to run. The services may not start at exactly
the same point in the boot process, but they are not started before the SMF
services, so that any service dependencies should be OK.</para>
</listitem>
</itemizedlist>
</sect1><sect1 xml:id="dzhid"><title>SMF Concepts</title><para>This section presents terms and their definitions within the SMF framework.
These terms are used throughout the documentation. To grasp SMF concepts,
an understanding of these terms is essential.</para><sect2 xml:id="dzhnj"><title>SMF Service</title><para><indexterm><primary>service (SMF)</primary><secondary>description</secondary></indexterm>The fundamental unit of administration in the SMF framework is
the <emphasis>service instance</emphasis>. Each SMF service has the potential
to have multiple versions of it configured. As well, multiple instances of
the same version can run on a single Solaris system. An <emphasis>instance</emphasis> is
a specific configuration of a service. A web server is a service. A specific
web server daemon that is configured to listen on port 80 is an instance.
Each instance of the web server service could have different configuration
requirements. The service has system-wide configuration requirements, but
each instance can override specific requirements, as needed. Multiple instances
of a single service are managed as child objects of the service object.</para><itemizedlist><para>Services are not just the representation for standard long-running system
services such as <command>in.dhcpd</command> or <command>nfsd</command>. Services
also represent varied system entities that include ISV applications such as
Oracle software. In addition, a service can include less traditional entities
such as the following:</para><listitem><para>A physical network device</para>
</listitem><listitem><para>A configured IP address</para>
</listitem><listitem><para>Kernel configuration information</para>
</listitem><listitem><para>Milestones that correspond to system init state, such as the
multiuser run level</para>
</listitem>
</itemizedlist><para>Generically, a service is an entity that provides a list of capabilities
to applications and other services, local and remote. A service is dependent
on an implicitly declared list of local services.</para><para>A <emphasis>milestone</emphasis> is a special type of service. Milestone
services represent high-level attributes of the system. For example, the services
which constitute run levels S, 2, and 3 are each represented by milestone
services.</para>
</sect2><sect2 xml:id="eqbuc"><title>Service Identifiers</title><indexterm><primary>FMRI</primary><secondary>description</secondary>
</indexterm><indexterm><primary>fault management resource identifier</primary><see>FMRI</see>
</indexterm><para>Each service instance is named with a Fault Management Resource Identifier
or FMRI. The FMRI includes the service name and the instance name. For example,
the FMRI for the <command>rlogin</command> service is <literal>svc:/network/login:rlogin</literal>, where <literal>network/login</literal> identifies the service
and <literal>rlogin</literal> identifies the service instance.</para><itemizedlist><para>Equivalent formats for an FMRI are as follows:</para><listitem><para><literal>svc://localhost/system/system-log:default</literal></para>
</listitem><listitem><para><literal>svc:/system/system-log:default</literal></para>
</listitem><listitem><para><literal>system/system-log:default</literal></para>
</listitem>
</itemizedlist><para>In addition, some SMF commands can use the following FMRI format: <literal>svc:/system/system-log</literal>. Some commands infer what instance to use,
when there is no ambiguity. See the SMF command manual pages, such as <citerefentry><refentrytitle>svcadm</refentrytitle><manvolnum>1M</manvolnum></citerefentry> or <citerefentry><refentrytitle>svcs</refentrytitle><manvolnum>1</manvolnum></citerefentry>, for instructions about which FMRI formats are appropriate.</para><itemizedlist><para>The service names usually include a general functional category. The
categories include the following:</para><listitem><para><literal>application</literal></para>
</listitem><listitem><para><literal>device</literal></para>
</listitem><listitem><para><literal>milestone</literal></para>
</listitem><listitem><para><literal>network</literal></para>
</listitem><listitem><para><literal>platform</literal></para>
</listitem><listitem><para><literal>site</literal></para>
</listitem><listitem><para><literal>system</literal></para>
</listitem>
</itemizedlist><para>Legacy <filename>init.d</filename> scripts are also represented with
FMRIs that start with <literal>lrc</literal> instead of <literal>svc</literal>,
for example: <literal>lrc:/etc/rcS_d/S35cacheos_sh</literal>. The legacy services
can be monitored using SMF. However, you cannot administer these services.</para><para>When booting a system for the first time with SMF, services listed in <filename>/etc/inetd.conf</filename> are automatically converted into SMF services.
The FMRIs for these services are slightly different. The syntax for a converted <command>inetd</command> services is:</para><screen>network/<replaceable>&lt;service-name&gt;</replaceable>/<replaceable>&lt;protocol&gt;</replaceable></screen><para>In addition, the syntax for a converted service that uses the RPC protocol
is:</para><screen><literal>network/rpc-</literal><replaceable>&lt;service-name&gt;</replaceable><literal>/rpc_</literal><replaceable>&lt;protocol&gt;</replaceable></screen><para>Where <replaceable>&lt;service-name&gt;</replaceable> is the name defined
in <filename>/etc/inetd.conf</filename> and <replaceable>&lt;protocol&gt;</replaceable> is
the protocol for the service. For instance, the FMRI for the <command>rpc.cmsd</command> service
is <literal>network/rpc-100068_2-5/rpc_udp</literal>.</para>
</sect2><sect2 xml:id="eywvn"><title>Service States</title><indexterm><primary>service states</primary><secondary>description</secondary>
</indexterm><itemizedlist><para>The <command>svcs</command> command displays the state, start time,
and FMRI of service instances. The state of each service is one of the following:</para><listitem><para><literal>degraded</literal> &ndash; The service instance is
enabled, but is running at a limited capacity.</para>
</listitem><listitem><para><literal>disabled</literal> &ndash; The service instance is
not enabled and is not running.</para>
</listitem><listitem><para><literal>legacy_run</literal> &ndash; The legacy service is
not managed by SMF, but the service can be observed. This state is only used
by legacy services.</para>
</listitem><listitem><para><literal>maintenance</literal> &ndash; The service instance
has encountered an error that must be resolved by the administrator.</para>
</listitem><listitem><para><literal>offline</literal> &ndash; The service instance is
enabled, but the service is not yet running or available to run.</para>
</listitem><listitem><para><literal>online</literal> &ndash; The service instance is
enabled and has successfully started.</para>
</listitem><listitem><para><literal>uninitialized</literal> &ndash; This state is the
initial state for all services before their configuration has been read.</para>
</listitem>
</itemizedlist>
</sect2><sect2 xml:id="esini"><title>SMF Manifests</title><indexterm><primary>manifests (SMF)</primary><secondary>description</secondary>
</indexterm><para>An SMF <emphasis>manifest</emphasis> is an XML file that contains a
complete set of properties that are associated with a service or a service
instance. The files are stored in <filename>/var/svc/manifest</filename>.
Manifests should not be used to modify the properties of a service. The service
configuration repository is the authoritative source of configuration information.
To incorporate information from the manifest into the repository, you must
either run <command>svccfg import</command> or allow the service to import
the information during a system boot.</para><para>See the <citerefentry><refentrytitle>service_bundle</refentrytitle><manvolnum>4</manvolnum></citerefentry> manual page for a complete description of the contents
of the SMF manifests. If you need to change the properties of a service, see
the <citerefentry><refentrytitle>svccfg</refentrytitle><manvolnum>1M</manvolnum></citerefentry> or <citerefentry><refentrytitle>inetadm</refentrytitle><manvolnum>1M</manvolnum></citerefentry> manual pages.</para>
</sect2><sect2 xml:id="fgoth"><title>SMF Profiles</title><indexterm><primary>profiles (SMF)</primary><secondary>description</secondary>
</indexterm><itemizedlist><para>An SMF <emphasis>profile</emphasis> is an XML file that lists a set
of service instances and whether each should be enabled or disabled. Some
profiles which are delivered with the Solaris release include:</para><listitem><para><filename>/var/svc/profile/generic_open.xml</filename> &ndash;
This profile enables the standard services that have been started by default
in earlier Solaris releases.</para>
</listitem><listitem><para><filename>/var/svc/profile/generic_limited_net.xml</filename> &ndash;
This profile disables many of the internet services that have be started by
default in earlier Solaris releases. The <literal>network/ssh</literal> service
is enabled to provide network connectivity.</para>
</listitem><listitem><para><literal>/var/svc/profile/ns_*.xml</literal> &ndash; These
profiles enable services associated with the name service that is configured
to run on the system.</para>
</listitem><listitem><para><literal>/var/svc/profile/platform_*.xml</literal> &ndash;
These profiles enable services associated with particular hardware platforms.</para>
</listitem>
</itemizedlist><para>During the first boot after a new installation or an upgrade to the
Solaris 10 release or any of the subsequent Solaris Express releases,
some Solaris profiles are automatically applied. To be specific, the <filename>/var/svc/profile/generic.xml</filename> profile is applied. This file is usually symbolically linked to <filename>generic_open.xml</filename> or <filename>generic_limited_net.xml</filename>.
Also, if a profile called <filename>site.xml</filename> is in <literal>/var/svc/profile</literal> during the first boot or is added between boots, the contents of
this profile are applied. By using the <filename>site.xml</filename> profile,
the initial set of enabled services may be customized by the administrator.</para><para>For more information about using profiles, see <xref linkend="fgour" />.</para>
</sect2><sect2 xml:id="dzhsi"><title>Service Configuration Repository</title><para><indexterm><primary>repository (SMF)</primary><secondary>description</secondary></indexterm><indexterm><primary>service configuration repository</primary><see>repository</see></indexterm><indexterm><primary>configuration repository (SMF)</primary><see>repository</see></indexterm>The <emphasis>service configuration repository</emphasis> stores
persistent configuration information as well as SMF runtime data for services.
The repository is distributed among local memory and local files. SMF is designed
so that eventually, service data can be represented in the network directory
service. The network directory service is not yet available. The data in the
service configuration repository allows for the sharing of configuration information
and administrative simplicity across many Solaris instances. The service configuration
repository can only be manipulated or queried using SMF interfaces. For more
information about manipulating and accessing the repository, see the
<citerefentry><refentrytitle>svccfg</refentrytitle><manvolnum>1M</manvolnum></citerefentry> and
<citerefentry><refentrytitle>svcprop</refentrytitle><manvolnum>1</manvolnum></citerefentry> manual pages. The service configuration
repository daemon is covered in the <citerefentry><refentrytitle>svc.configd</refentrytitle><manvolnum>1M</manvolnum></citerefentry> manual page. The service configuration
library is documented in the <citerefentry><refentrytitle>libscf</refentrytitle><manvolnum>3LIB</manvolnum></citerefentry> manual page.</para>
</sect2>
<sect2 xml:id="frjjz">
<title>SMF Repository Backups</title>
<itemizedlist>
	<para>SMF automatically takes the following backups of the repository:</para>
	<listitem><para>The boot backup is taken immediately before the first change to the repository is made during each system startup.</para></listitem>
	<listitem><para>The <literal>manifest_import</literal> backup occurs after <filename>svc:/system/manifest-import:default</filename> completes, if it imported any new manifests or ran any upgrade scripts.</para></listitem>
</itemizedlist>
<para>Four backups of each type are maintained by the system. The system deletes
the oldest backup, when necessary. The backups are stored as <filename>/etc/svc/repository</filename>-<replaceable>type</replaceable>-<replaceable>YYYYMMDD_HHMMSWS</replaceable>,
where <replaceable>YYYYMMDD</replaceable> (year, month, day) and <replaceable>HHMMSS</replaceable> (hour, minute, second), are the date and time when the backup
was taken. Note that the hour format is based on a 24&ndash;hour clock.</para><para>You can restore the repository from these backups, if an error occurs.
To do so, use the <command>/lib/svc/bin/restore_repository</command> command.
For more information, see <xref linkend="ecduh" />.</para>
</sect2><sect2 xml:id="eqbts"><title>SMF Snapshots</title><indexterm><primary>snapshots (SMF)</primary><secondary>description</secondary>
</indexterm><itemizedlist><para>The data in the service configuration repository includes <emphasis>snapshots</emphasis>, as well as a configuration that can be edited. Data about each
service instance is stored in the snapshots. The standard snapshots are as
follows:</para><listitem><para><literal>initial</literal> &ndash; Taken on the first import
of the manifest</para>
</listitem><listitem><para><literal>running</literal> &ndash; Used when the service methods
are executed</para>
</listitem><listitem><para><literal>start</literal> &ndash; Taken at the last successful
start</para>
</listitem>
</itemizedlist><para>The SMF service always executes with the <literal>running</literal> snapshot.
This snapshot is automatically created if it does not exist.</para><para>The <command>svcadm</command> <option role="nodash">refresh</option> command,
sometimes followed by the <command>svcadm</command> <option role="nodash">restart</option> command, makes a snapshot active. The <command>svccfg</command> command
is used to view or revert to instance configurations in a previous snapshot.
See <xref linkend="ecdpn" /> for
more information.</para>
</sect2>
</sect1><sect1 xml:id="dzhjy"><title>SMF Administrative and Programming Interfaces</title><para>This section introduces the interfaces that are available when you use
SMF.</para><sect2 xml:id="dzhqq"><title>SMF Command-Line Administrative Utilities</title><indexterm><primary>commands (SMF)</primary><secondary>list of</secondary>
</indexterm><indexterm><primary>SMF</primary><secondary>commands</secondary>
</indexterm><para>SMF provides a set of command-line utilities that interact with SMF
and accomplish standard administrative tasks. The following utilities can
be used to administer SMF.</para><table frame="topbot" xml:id="dzhal"><title>Service Management Facility Utilities</title><tgroup cols="2" colsep="0" rowsep="0"><colspec colnum="1" colname="column1" colwidth="3*"/><colspec colnum="2" colname="column2" colwidth="7*"/><thead><row rowsep="1"><entry colname="column1" align="left" valign="bottom"><para>Command Name</para>
</entry><entry colname="column2" align="left" valign="bottom"><para>Function</para>
</entry>
</row>
</thead><tbody><row><entry colname="column1" align="left" valign="top"><para><command>inetadm</command></para>
</entry><entry colname="column2" align="left" valign="top"><para>Provides the ability to observe or configure services controlled by <command>inetd</command><indexterm><primary><command>inetadm</command> command</primary><secondary>description</secondary></indexterm></para>
</entry>
</row><row><entry colname="column1" align="left" valign="top"><para><command>svcadm</command></para>
</entry><entry colname="column2" align="left" valign="top"><para>Provides the ability to perform common service management tasks, such
as enabling, disabling, or restarting service instances<indexterm><primary><command>svcadm</command> command</primary><secondary>description</secondary></indexterm></para>
</entry>
</row><row><entry colname="column1" align="left" valign="top"><para><command>svccfg</command></para>
</entry><entry colname="column2" align="left" valign="top"><para>Provides the ability to display and manipulate the contents of the service
configuration repository<indexterm><primary><command>svccfg</command> command</primary><secondary>description</secondary></indexterm></para>
</entry>
</row><row><entry colname="column1" align="left" valign="top"><para><command>svcprop</command></para>
</entry><entry colname="column2" align="left" valign="top"><para>Retrieves property values from the service configuration repository
with a output format appropriate for use in shell scripts<indexterm><primary><command>svcprop</command> command</primary><secondary>description</secondary></indexterm></para>
</entry>
</row><row><entry colname="column1" align="left" valign="top"><para><command>svcs</command></para>
</entry><entry colname="column2" align="left" valign="top"><para>Gives detailed views of the service state of all service instances in
the service configuration repository<indexterm><primary><command>svcs</command> command</primary><secondary>description</secondary></indexterm></para>
</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2><sect2 xml:id="dzgzv"><title>Service Management Configuration Library Interfaces</title><indexterm><primary>SMF</primary><secondary>library interfaces</secondary>
</indexterm><indexterm><primary>library interfaces</primary><secondary>SMF</secondary>
</indexterm><para>SMF provides a set of programming interfaces that are used to interact
with the service configuration repository through the <command>svc.configd</command> daemon.
This daemon is the arbiter of all requests to the local repository datastores.
A set of fundamental interfaces is defined as the lowest level of interaction
possible with services in the service configuration repository. The interfaces
provide access to all service configuration repository features such as transactions
and snapshots.</para><para>Many developers only need a set of common tasks to interact with SMF.
These tasks are implemented as convenience functions on top of the fundamental
services to ease the implementation burden.</para>
</sect2>
</sect1><sect1 xml:id="dzhna"><title>SMF Components</title><para>SMF includes a master restarter daemon and delegated restarters.</para><sect2 xml:id="dzhgs"><title>SMF Master Restarter Daemon</title><indexterm><primary><command>svc.startd</command>daemon</primary><secondary>description</secondary>
</indexterm><para>The <command>svc.startd</command> daemon is the master process starter
and restarter for the Solaris OS. The daemon is responsible for managing service
dependencies for the entire system. The daemon takes on the previous responsibility
that <command>init</command> held of starting the appropriate <filename>/etc/rc*.d</filename> scripts at the appropriate run levels. First, <command>svc.startd</command> retrieves
the information in the service configuration repository. Next, the daemon
starts services when their dependencies are met. The daemon is also responsible
for restarting services that have failed and for shutting down services whose
dependencies are no longer satisfied. The daemon keeps track of service state
through an operating system view of availability through events such as process
death. </para>
</sect2><sect2 xml:id="dzhsa"><title>SMF Delegated Restarters</title><indexterm><primary>SMF</primary><secondary>delegated restarters</secondary>
</indexterm><indexterm><primary>delegated restarters (SMF)</primary>
</indexterm><indexterm><primary>restarters (SMF)</primary>
</indexterm><para>Some services have a set of common behaviors on startup. To provide
commonality among these services, a delegated restarter might take responsibility
for these services. In addition, a delegated restarter can be used to provide
more complex or application-specific restarting behavior. The delegated restarter
can support a different set of methods, but exports the same service states
as the master restarter. The restarter's name is stored with the service.
A current example of a delegated restarter is <command>inetd</command>, which
can start Internet services on demand, rather than having the services always
running. </para>
</sect2>
</sect1><sect1 xml:id="fddwo"><title>SMF and Booting</title><itemizedlist><para>SMF provides new methods for booting a system. For instance:</para><listitem><para>There is a additional system state which is associated with
the <literal>all</literal> milestone. With the <literal>all</literal> milestone,
all of the services with a defined dependency on the <literal>multi-user-server</literal> milestone
are started, as well as any services that do not have a defined dependency.
If you have added services, such as third party products, they may not be
started automatically unless you use the following command:</para><screen>ok <userinput>boot -m milestone=all</userinput></screen>
</listitem><listitem><para>When booting a system, you can choose to use the verbose option
to see more messages. By default, the system will not display these messages.
To boot in the verbose mode, use the following command:</para><screen>ok <userinput>boot -mverbose</userinput></screen>
</listitem><listitem><para>There is a new system state which is associated with the <literal>none</literal> milestone. Only <command>init</command>, <command>svc.startd</command> and <command>svc.configd</command> are started if you boot a system using this milestone.
This state can be very useful for debugging booting problems. In particular,
debugging any problems with the configuration of SMF services is made simpler,
because none of the services are started. See <xref linkend="ecdwu" /> for instructions on how to use
the <literal>none</literal> milestone.</para>
</listitem>
</itemizedlist>
</sect1><sect1 xml:id="dzhkf"><title>SMF Compatibility</title><para>While many standard Solaris services are now managed by SMF, the scripts
placed in <filename>/etc/rc*.d</filename> continue to be executed on run-level
transitions. Most of the <filename>/etc/rc*.d</filename> scripts that were
included in previous Solaris releases have been removed as part of SMF. The
ability to continue to run the remaining scripts allows for third-party applications
to be added without having to convert the services to use SMF.</para><para>In addition, <filename>/etc/inittab</filename> and <filename>/etc/inetd.conf</filename> must be available for packages to amend with postinstall scripts.
These are called legacy-run services. The <command>inetconv</command> command
is run to add these legacy-run services to the service configuration repository.
The status of these services can be viewed, but no other changes are supported
through SMF. Applications that use this feature will not benefit from the
precise fault containment provided by SMF.</para><para>Applications converted to utilize SMF should no longer make modifications
to the <filename>/etc/inittab</filename> and <filename>/etc/inetd.conf</filename> files.
The converted applications will not use the <filename>/etc/rc*.d</filename> scripts.
Also, the new version of <command>inetd</command> does not look for entries
in <command>/etc/inetd.conf</command>.</para>
</sect1><sect1 xml:id="hbrunlevels-13026"><title>Run Levels</title><para><indexterm xml:id="hbrunlevels-ix934"><primary>run level</primary><secondary>definition</secondary></indexterm><indexterm xml:id="hbrunlevels-ix935"><primary>run level</primary><secondary>default run level</secondary></indexterm><indexterm xml:id="hbrunlevels-ix936"><primary>init states</primary><see>run levels</see></indexterm>A system's <emphasis>run level</emphasis> (also known as an <emphasis>init state</emphasis>) defines what services and resources are available to
users. A system can be in only one run level at a time.   </para><para>The Solaris OS has eight run levels, which are described in the following
table. The default run level is specified in the <filename>/etc/inittab</filename> file
as run level 3.</para><table frame="topbot" pgwide="1" xml:id="hbrunlevels-72176"><title>Solaris Run
Levels</title><tgroup cols="4" colsep="0" rowsep="0"><colspec colname="column1" colwidth="46*"/><colspec colname="column2" colwidth="105*"/><colspec colname="column3" colwidth="80*"/><colspec colname="column4" colwidth="146*"/><thead><row rowsep="1"><entry><para>Run Level</para>
</entry><entry><para>Init State</para>
</entry><entry><para>Type</para>
</entry><entry><para>Purpose</para>
</entry>
</row>
</thead><tbody><row><entry><para>0</para>
</entry><entry><para>Power-down state</para>
</entry><entry><para>Power-down</para>
</entry><entry><para><indexterm xml:id="hbrunlevels-ix937"><primary>run level</primary><secondary>0 (power-down level)</secondary></indexterm>To shut down the operating system
so that it is safe to turn off power to the system. </para>
</entry>
</row><row><entry><para><indexterm xml:id="hbrunlevels-ix943"><primary>run level</primary><secondary>s or S (single-user level)</secondary></indexterm>s or S </para>
</entry><entry><para><indexterm xml:id="hbrunlevels-ix944"><primary>single-user level</primary><see>run level s or S</see></indexterm>Single-user state </para>
</entry><entry><para>Single-user</para>
</entry><entry><para>To run as a single user with some file systems mounted and accessible. </para>
</entry>
</row><row><entry><para>1</para>
</entry><entry><para>Administrative state</para>
</entry><entry><para>Single-user</para>
</entry><entry><para><indexterm xml:id="hbrunlevels-ix938"><primary>run level</primary><secondary>1 (single-user level)</secondary></indexterm>To access all available file systems.
User logins are disabled.</para>
</entry>
</row><row><entry><para>2</para>
</entry><entry><para>Multiuser state</para>
</entry><entry><para>Multiuser</para>
</entry><entry><para><indexterm xml:id="hbrunlevels-ix939"><primary>run level</primary><secondary>2 (multiuser level)</secondary></indexterm>For normal operations. Multiple users
can access the system and all file system. All daemons are running except
for the NFS server daemons. </para>
</entry>
</row><row><entry><para>3</para>
</entry><entry><para><indexterm xml:id="hbrunlevels-ix940"><primary>multiuser level</primary><see>run level 3</see></indexterm>Multiuser level with NFS resources shared </para>
</entry><entry><para>Multiuser</para>
</entry><entry><para><indexterm xml:id="hbrunlevels-ix941"><primary>run level</primary><secondary>3 (multiuser with NFS)</secondary></indexterm>For normal operations with NFS
resources shared. This is the default run level for the Solaris OS.</para>
</entry>
</row><row><entry><para>4</para>
</entry><entry><para>Alternative multiuser state</para>
</entry><entry><para></para>
</entry><entry><para>Not configured by default, but available for customer use.</para>
</entry>
</row><row><entry><para>5</para>
</entry><entry><para>Power-down state</para>
</entry><entry><para>Power-down</para>
</entry><entry><para>To shut down the operating system so that it is safe to turn off power
to the system. If possible, automatically turns off power on systems that
support this feature.</para>
</entry>
</row><row><entry><para>6</para>
</entry><entry><para>Reboot state</para>
</entry><entry><para>Reboot</para>
</entry><entry><para><indexterm xml:id="hbrunlevels-ix942"><primary>run level</primary><secondary>6 (reboot level)</secondary></indexterm>To shut down the system to run level
0, and then reboot to multiuser level with NFS resources shared (or whatever
level is the default in the <filename>inittab</filename> file). </para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>In addition, the <command>svcadm</command> command can be used to change
the run level of a system, by selecting a milestone at which to run. The following
table shows which run level corresponds to each milestone.</para><table frame="topbot" xml:id="fahqq"><title>Solaris Run Levels and SMF Milestones</title><tgroup cols="2" colsep="0" rowsep="0"><colspec colwidth="20*"/><colspec colwidth="80*"/><thead><row rowsep="1"><entry><para>Run Level</para>
</entry><entry><para>SMF Milestone FMRI</para>
</entry>
</row>
</thead><tbody><row><entry><para>S</para>
</entry><entry><para><literal>milestone/single-user:default</literal></para>
</entry>
</row><row><entry><para>2</para>
</entry><entry><para><literal>milestone/multi-user:default</literal></para>
</entry>
</row><row><entry><para>3</para>
</entry><entry><para><literal>milestone/multi-user-server:default</literal></para>
</entry>
</row>
</tbody>
</tgroup>
</table><sect2 xml:id="geeia"><title>When to Use Run Levels or Milestones</title><para>Under most circumstances, using the <command>init</command> command
with a run level to change the system state is sufficient. Using milestones
to change system state can be confusing and can lead to unexpected behavior.
In addition, the <command>init</command> command allows for the system to
be shutdown, so <command>init</command> is the best command for changing system
state.</para><para>However, booting a system using the <literal>none</literal> milestone,
can be very useful when debugging startup problems. There is no equivalent
run level to the <literal>none</literal> milestone. See <xref linkend="ecdwu" /> for specific instructions.</para>
</sect2><sect2 xml:id="hbrunlevels-25070"><title>Determining a System's Run Level</title><para>Display run level information by using the <command>who -r</command> command.</para><screen>$ <userinput>who -r</userinput></screen><para><indexterm xml:id="hbrunlevels-ix945"><primary>run level</primary><secondary>determining (how to)</secondary></indexterm><indexterm xml:id="hbrunlevels-ix946"><primary><command>who</command> command</primary></indexterm><indexterm><primary>determining</primary><secondary>system's run level (how to)</secondary></indexterm>Use the <command>who
-r</command> command to determine a system's current run level for any level. </para><example xml:id="hbrunlevels-1"><title>Determining a System's Run Level</title><para>This example displays information about a system's current run level
and previous run levels.</para><screen>$ <userinput>who -r</userinput>
 .    run-level 3  Dec 13 10:10  3  0 S
$</screen><informaltable frame="topbot"><tgroup cols="2" colsep="0" rowsep="0"><colspec colwidth="50*"/><colspec colwidth="50*"/><thead><row rowsep="1"><entry><para>Output of <command>who</command> <option>r</option> command</para>
</entry><entry><para>Description</para>
</entry>
</row>
</thead><tbody><row><entry><para><literal>run-level 3</literal></para>
</entry><entry><para>Identifies the current run level</para>
</entry>
</row><row><entry><para><literal>Dec 13 10:10</literal></para>
</entry><entry><para>Identifies the date of last run level change</para>
</entry>
</row><row><entry><para><literal>3</literal></para>
</entry><entry><para>Also identifies the current run level</para>
</entry>
</row><row><entry><para><literal>0</literal></para>
</entry><entry><para>Identifies the number of times the system has been at this run level
since the last reboot</para>
</entry>
</row><row><entry><para><literal>S</literal></para>
</entry><entry><para>Identifies the previous run level</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
</sect2>
</sect1><sect1 xml:id="hbrunlevels-12863"><title><filename>/etc/inittab</filename> File</title><itemizedlist><para><indexterm><primary sortas="etc/inittab file"><filename>/etc/inittab</filename> file</primary></indexterm>When you boot the system or change run levels with the <command>init</command> or <command>shutdown</command> command, the <command>init</command> daemon
starts processes by reading information from the <filename>/etc/inittab</filename> file.
This file defines these important items for the <command>init</command> process:</para><listitem><para>That the <command>init</command> process will restart</para>
</listitem><listitem><para>What processes to start, monitor, and restart if they terminate</para>
</listitem><listitem><para>What actions to take when the system enters a new run level</para>
</listitem>
</itemizedlist><para>Each entry in the <filename>/etc/inittab</filename> file has the following
fields:</para><para><replaceable>id</replaceable><filename>:</filename><replaceable>rstate</replaceable><filename>:</filename><replaceable>action</replaceable><filename>:</filename><replaceable>process</replaceable></para><para><indexterm xml:id="hbrunlevels-ix948"><primary sortas="etc/inittab file"><filename>/etc/inittab</filename> file</primary><secondary sortas="">entry description</secondary></indexterm>The following table describes the fields in an <filename>inittab</filename> entry. </para><table frame="topbot" xml:id="hbrunlevels-92201"><title>Fields Descriptions for
the <filename>inittab</filename> File</title><tgroup cols="2" colsep="0" rowsep="0"><colspec colname="column1" colwidth="87*"/><colspec colname="column2" colwidth="290*"/><thead><row rowsep="1"><entry><para>Field</para>
</entry><entry><para>Description</para>
</entry>
</row>
</thead><tbody><row><entry><para><replaceable>id</replaceable></para>
</entry><entry><para>Is a unique identifier for the entry.</para>
</entry>
</row><row><entry><para><replaceable>rstate</replaceable></para>
</entry><entry><para>Lists the run levels to which this entry applies.</para>
</entry>
</row><row><entry><para><replaceable>action</replaceable></para>
</entry><entry><para>Identifies how the process that is specified in the process field is
to be run. Possible values include: <literal>sysinit</literal>, <literal>boot</literal>, <literal>bootwait</literal>, <literal>wait</literal>, and <literal>respawn</literal>.</para><para>For a description of the other action keywords, see <citerefentry><refentrytitle>inittab</refentrytitle><manvolnum>4</manvolnum></citerefentry>.</para>
</entry>
</row><row><entry><para><replaceable>process</replaceable></para>
</entry><entry><para>Defines the command or script to execute.</para>
</entry>
</row>
</tbody>
</tgroup>
</table><example xml:id="hbrunlevels-2"><title>Default <filename>inittab</filename> File</title><para><indexterm xml:id="hbrunlevels-ix949"><primary sortas="etc/inittab file"><filename>/etc/inittab</filename> file</primary><secondary sortas="">example of default</secondary></indexterm>The following example shows a default <filename>inittab</filename> file
that is installed with the Solaris release. A description for each line of
output in this example follows.</para><screen width="100">ap::sysinit:/sbin/autopush -f /etc/iu.ap  <lineannotation>(1)</lineannotation>
sp::sysinit:/sbin/soconfig -f /etc/sock2path             <lineannotation>(2)</lineannotation>
smf::sysinit:/lib/svc/bin/svc.startd    &gt;/dev/msglog 2&lt;&gt;/dev/msglog      <lineannotation>(3)</lineannotation>
p3:s1234:powerfail:/usr/sbin/shutdown -y -i5 -g0 &gt;/dev/msglog 2&lt;&gt;/dev/...<lineannotation>(4)</lineannotation></screen><orderedlist><listitem><para>Initializes STREAMS modules</para>
</listitem><listitem><para>Configures socket transport providers</para>
</listitem><listitem><para>Initializes the master restarter for SMF</para>
</listitem><listitem><para>Describes a power fail shutdown</para>
</listitem>
</orderedlist>
</example><sect2 xml:id="hbrunlevels-3"><title>What Happens When the System Is Brought to
Run Level 3</title><orderedlist><listitem><para>The <literal>init</literal> process is started and reads the <filename>/etc/default/init</filename> file to set any environment variables. By default,
only the <literal>TIMEZONE</literal> variable is set.</para>
</listitem><listitem><orderedlist><para>Then, <literal>init</literal> reads the <filename>inittab</filename> file
and does the following:</para><listitem><para>Executes any process entries that have <literal>sysinit</literal> in
the <literal>action</literal> field so that any special initializations can
take place before users login.</para>
</listitem><listitem><para>Passes the startup activities to <command>svc.startd</command>.</para>
</listitem>
</orderedlist><para><indexterm xml:id="hbrunlevels-ix950"><primary>run level</primary><secondary>3 (multiuser with NFS)</secondary><tertiary>what happens when system is brought to</tertiary></indexterm>For a detailed description of how the <literal>init</literal> process
uses the <filename>inittab</filename> file, see <citerefentry><refentrytitle>init</refentrytitle><manvolnum>1M</manvolnum></citerefentry>.</para>
</listitem>
</orderedlist>
</sect2>
</sect1>
</chapter>
