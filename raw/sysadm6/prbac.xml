<chapter xml:id="prbac-1">
<title>Using Roles and Privileges (Overview)</title>
<para>Solaris role-based access control (RBAC) and privileges provide a more
secure alternative to superuser. This chapter provides overview information
about RBAC and about privileges.</para>
<itemizedlist>
	<para>The following is a list of the overview information in this chapter.</para>
	<listitem><para><xref linkend="rbac-1" /></para></listitem>
	<listitem><para><xref linkend="prbac-2" /></para></listitem>
</itemizedlist>
<sect1 xml:id="rbac-1"><title>Role-Based Access Control (Overview)</title><indexterm><primary>process rights management</primary><see>privileges</see>
</indexterm><para>Role-based access control (RBAC) is a security feature for controlling
user access to tasks that would normally be restricted to superuser. By applying
security attributes to processes and to users, RBAC can divide up superuser
capabilities among several administrators. Process rights management is implemented
through <firstterm>privileges</firstterm>. User rights management is implemented
through RBAC.</para><itemizedlist><listitem><para>For a discussion of process rights management, see <xref linkend="prbac-2" />.</para>
</listitem><listitem><para>For information on RBAC tasks, see <xref linkend="rbactask-1" />.</para>
</listitem><listitem><para>For reference information, see <olink targetptr="rbacref-1" remap="internal">Chapter&nbsp;10,
Role-Based Access Control (Reference)</olink>.</para>
</listitem>
</itemizedlist><sect2 xml:id="rbac-28"><title>RBAC: An Alternative to the Superuser
Model</title><indexterm><primary>role-based access control</primary><see>RBAC</see>
</indexterm><indexterm><primary>RBAC</primary><secondary>compared to superuser model</secondary>
</indexterm><indexterm><primary>superuser</primary><secondary>compared to RBAC model</secondary>
</indexterm><indexterm><primary>system security</primary><secondary>role-based access control (RBAC)</secondary>
</indexterm><para>In conventional UNIX systems, the <literal>root</literal> user, also
referred to as superuser, is all-powerful. Programs that run as <literal>root</literal>,
or <command>setuid</command> programs, are all-powerful. The <literal>root</literal> user
has the ability to read and write to any file, run all programs, and send
kill signals to any process. Effectively, anyone who can become superuser
can modify a site's firewall, alter the audit trail, read confidential records,
and shut down the entire network. A <command>setuid</command> program that
is hijacked can do anything on the system.</para><para><indexterm><primary>roles</primary><secondary>recommended roles</secondary></indexterm><indexterm><primary>roles</primary><secondary>use in RBAC</secondary></indexterm>Role-based access control (RBAC) provides a more secure alternative
to the all-or-nothing superuser model. With RBAC, you can enforce security
policy at a more fine-grained level. RBAC uses the security principle of <firstterm>least privilege</firstterm>. Least privilege means that a user has precisely
the amount of privilege that is necessary to perform a job. Ordinary users
have enough privilege to use their applications, check the status of their
jobs, print files, create new files, and so on. Capabilities beyond ordinary
user capabilities are grouped into rights profiles. Users who are expected
to do jobs that require some of the capabilities of superuser assume a role
that includes the appropriate rights profile.</para><para>RBAC collects superuser capabilities into <firstterm>rights profiles</firstterm>.
These rights profiles are assigned to special user accounts that are called <emphasis>roles</emphasis>. A user can then assume a role to do a job that requires
some of superuser's capabilities. Predefined rights profiles are supplied
with Solaris software. You create the roles and assign the profiles.</para><para>Rights profiles can provide broad capabilities. For example, the Primary
Administrator rights profile is equivalent to superuser. Rights profiles can
also be narrowly defined. For example, the Cron Management rights profile
manages <command>at</command> and <command>cron</command> jobs. When you create
roles, you can decide to create roles with broad capabilities, or roles with
narrow capabilities, or both.</para><para>In the RBAC model, superuser creates one or more roles. The roles are
based on rights profiles. Superuser then assigns the roles to users who are
trusted to perform the tasks of the role. Users log in with their user name.
After login, users assume roles that can run restricted administrative commands
and graphical user interface (GUI) tools. </para><itemizedlist><para>The flexibility in setting up roles enables a variety of security policies.
Although no roles are shipped with the Solaris Operating System (Solaris OS), three recommended
roles can easily be configured. The roles are based on rights profiles of
the same name:</para><listitem><para><indexterm><primary>Primary Administrator (RBAC)</primary><secondary>recommended role</secondary></indexterm><emphasis role="strong">Primary
Administrator &ndash;</emphasis> A powerful role that is equivalent to the <literal>root</literal> user, or superuser.</para>
</listitem><listitem><para><indexterm><primary>System Administrator (RBAC)</primary><secondary>recommended role</secondary></indexterm><emphasis role="strong">System
Administrator &ndash;</emphasis> A less powerful role for administration that
is not related to security. This role can manage file systems, mail, and software
installation. However, this role cannot set passwords.</para>
</listitem><listitem><para><indexterm><primary>Operator (RBAC)</primary><secondary>recommended role</secondary></indexterm><emphasis role="strong">Operator &ndash;</emphasis> A
junior administrator role for operations such as backups and printer management.</para>
</listitem>
</itemizedlist><para>These three roles do not have to be implemented. Roles are a function
of an organization's security needs. Roles can be set up for special-purpose
administrators in areas such as security, networking, or firewall administration.
Another strategy is to create a single powerful administrator role along with
an advanced user role. The advanced user role would be for users who are permitted
to fix portions of their own systems.</para><para>The superuser model and the RBAC model can co-exist. The following table
summarizes the gradations from superuser to restricted ordinary user that
are possible in the RBAC model. The table includes the administrative actions
that can be tracked in both models. For a summary of the effect of privileges
alone on a system, see <xref linkend="prbac-tbl-1" />.</para><table frame="topbot" xml:id="rbac-tbl-7"><title>Superuser Model Versus RBAC With
Privileges Model</title><tgroup cols="3" colsep="0" rowsep="0"><colspec colwidth="61.14*"/><colspec colname="colspec0" colwidth="36.12*"/><colspec colwidth="52.74*"/><thead><row><entry rowsep="1"><para>User Capabilities on a System</para>
</entry><entry rowsep="1"><para>Superuser Model</para>
</entry><entry rowsep="1"><para>RBAC Model</para>
</entry>
</row>
</thead><tbody><row><entry><para>Can become superuser with full superuser capability</para>
</entry><entry><para>Yes</para>
</entry><entry><para>Yes</para>
</entry>
</row><row><entry><para>Can log in as a user with full user capabilities</para>
</entry><entry><para>Yes</para>
</entry><entry><para>Yes</para>
</entry>
</row><row><entry><para>Can become superuser with limited capabilities</para>
</entry><entry><para>No</para>
</entry><entry><para>Yes</para>
</entry>
</row><row><entry><para>Can log in as a user, and have superuser capabilities, sporadically</para>
</entry><entry><para>Yes, with <command>setuid</command> programs only</para>
</entry><entry><para>Yes, with <command>setuid</command> programs and with RBAC</para>
</entry>
</row><row><entry><para>Can log in as a user with administrative capabilities, but without full
superuser capability</para>
</entry><entry><para>No</para>
</entry><entry><para>Yes, with RBAC and with directly-assigned privileges and authorizations</para>
</entry>
</row><row><entry><para>Can log in as a user with fewer capabilities than an ordinary user</para>
</entry><entry><para>No</para>
</entry><entry><para>Yes, with RBAC and with removed privileges</para>
</entry>
</row><row><entry><para>Can track superuser actions</para>
</entry><entry><para>Yes, by auditing the <command>su</command> command</para>
</entry><entry><para>Yes, by auditing profile shell commands</para><para>Also, if <literal>root</literal> user is disabled, the name of the user
who has assumed the <literal>root</literal> role is in the audit trail</para>
</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2><sect2 xml:id="rbac-29"><title>Solaris RBAC Elements and Basic Concepts</title><indexterm><primary>profiles</primary><see>rights profiles</see>
</indexterm><indexterm><primary>RBAC</primary><secondary>elements</secondary>
</indexterm><indexterm><primary>components</primary><secondary>RBAC</secondary>
</indexterm><indexterm><primary>RBAC</primary><secondary>basic concepts</secondary>
</indexterm><itemizedlist><para>The RBAC model in the Solaris OS introduces the following elements:</para><listitem><para><indexterm><primary>authorizations (RBAC)</primary><secondary>description</secondary></indexterm><emphasis role="strong">Authorization &ndash;</emphasis> A
permission that enables a user or role to perform a class of actions that
could affect security. For example, security policy at installation gives
ordinary users the <literal>solaris.device.cdrw</literal> authorization. This
authorization enables users to read and write to a CD-ROM device. For a list
of authorizations, see the <filename>/etc/security/auth_attr</filename> file.</para>
</listitem><listitem><para><indexterm><primary>privileges</primary><secondary>description</secondary></indexterm><emphasis role="strong">Privilege &ndash;</emphasis> A discrete
right that can be granted to a command, a user, a role, or a system. Privileges
enable a process to succeed. For example, the <literal>proc_exec</literal> privilege
allows a process to call <function>execve</function>. Ordinary users have
basic privileges. To see your basic privileges, run the <command>ppriv -vl
basic</command> command.</para>
</listitem><listitem><para><indexterm><primary>privileges</primary><secondary>description</secondary></indexterm><emphasis role="strong">Security attributes &ndash;</emphasis> An
attribute that enables a process to perform an operation. In a typical UNIX
environment, a security attribute enables a process to perform an operation
that is otherwise forbidden to ordinary users. For example, <command>setuid</command> and <command>setgid</command> programs have security attributes. In the RBAC model, operations
that ordinary users perform might require security attributes. In addition
to <command>setuid</command> and <command>setgid</command> programs, authorizations
and privileges are also security attributes in the RBAC model. For example,
a user with the <literal>solaris.device.allocate</literal> authorization can
allocate a device for exclusive use. A process with the <literal>sys_time</literal> privilege
can manipulate system time.</para>
</listitem><listitem><para><indexterm><primary>privileged application</primary><secondary>description</secondary></indexterm><emphasis role="strong">Privileged application &ndash;</emphasis> An
application or command that can override system controls by checking for <firstterm>security attributes</firstterm>. In a typical UNIX environment and in the
RBAC model, programs that use <command>setuid</command> and <command>setgid</command> are
privileged applications. In the RBAC model, programs that require privileges
or authorizations to succeed are also privileged applications. For more information,
see <xref linkend="rbac-30" />.</para>
</listitem><listitem><para><indexterm><primary>rights profiles</primary><secondary>description</secondary></indexterm><indexterm><primary>security attributes</primary><secondary>description</secondary></indexterm><emphasis role="strong">Rights
profile &ndash;</emphasis> A collection of administrative capabilities that
can be assigned to a role or to a user. A rights profile can consist of authorizations,
of commands with security attributes, and of other rights profiles. Rights
profiles offer a convenient way to group security attributes.</para>
</listitem><listitem><para><indexterm><primary>roles</primary><secondary>summary</secondary></indexterm><emphasis role="strong">Role &ndash;</emphasis> A special identity
for running privileged applications. The special identity can be assumed by
assigned users only. In a system that is run by roles, superuser is unnecessary.
Superuser capabilities are distributed to different roles. For example, in
a two-role system, security tasks would be handled by a security role. The
second role would handle system administration tasks that are not security-related.
Roles can be more fine-grained. For example, a system could include separate
administrative roles for handling the cryptographic framework, printers, system
time, file systems, and auditing.</para>
</listitem>
</itemizedlist><para>The following figure shows how the RBAC elements work together.</para><figure xml:id="rbac-fig-2"><title>Solaris RBAC Element Relationships</title><mediaobject><imageobject><imagedata entityref="rbac.elems.eps"/>
</imageobject><textobject><simpara>The following context describes the graphic.</simpara>
</textobject>
</mediaobject>
</figure><para>In RBAC, roles are assigned to users. When a user assumes a role, the
capabilities of the role are available. Roles get their capabilities from
rights profiles. Rights profiles can contain authorizations, privileged commands,
and other supplementary rights profiles. Privileged commands are commands
that execute with security attributes.</para><para>The following figure uses the Operator role, the Operator rights profile,
and the Printer Management rights profile to demonstrate RBAC relationships.</para><figure xml:id="rbac-fig-1"><title>Example of Solaris RBAC Element Relationships</title><mediaobject><imageobject><imagedata entityref="rbac.ex.eps"/>
</imageobject><textobject><simpara>The following context describes the graphic.</simpara>
</textobject>
</mediaobject>
</figure><para>The Operator role is used to maintain printers and to perform media
backup. The role is assigned to the user <literal>jdoe</literal>. <literal>jdoe</literal> can
assume the role by switching to the role, and then supplying the role password.</para><para>The Operator rights profile has been assigned to the Operator role.
The Operator rights profile contains two supplementary profiles, Printer Management
and Media Backup. The supplementary profiles reflect the role's primary tasks.</para><para><indexterm><primary>security attributes</primary><secondary>Printer management rights profile</secondary></indexterm>The Printer Management rights
profile is for managing printers, print daemons, and spoolers. Three authorizations
are included in the Printer Management rights profile: <literal>solaris.admin.printer.read</literal>, <literal>solaris.admin.printer.delete</literal>, and <literal>solaris.admin.printer.modify</literal>. These authorizations enable roles and users to manipulate information
in the printer queue. The Printer Management rights profile also includes
a number of commands with security attributes, such as <command>/usr/sbin/lpshut</command> with <literal>euid=lp</literal> and <command>/usr/ucb/lpq</command> with <literal>euid=0</literal>.</para>
</sect2><sect2 xml:id="rbac-32"><title>RBAC Authorizations</title><indexterm><primary>authorizations (RBAC)</primary><secondary>definition</secondary>
</indexterm><indexterm><primary>RBAC</primary><secondary>authorizations</secondary>
</indexterm><para>An <emphasis>authorization</emphasis> is a discrete right that can be
granted to a role or to a user. Authorizations enforce policy at the user
application level. Authorizations can be assigned directly to a role or to
a user. Typically, authorizations are included in a rights profile. The rights
profile is then included in a role, and the role is assigned to a user. For
an example, see <xref linkend="rbac-fig-1" />.</para><itemizedlist><para>RBAC-compliant applications can check a user's authorizations prior
to granting access to the application or specific operations within the application.
This check replaces the check in conventional UNIX applications for <literal>UID=0</literal>. For more information on authorizations, see the following sections:</para><listitem><para><xref linkend="rbacref-28" /></para>
</listitem><listitem><para><xref linkend="rbacref-11" /></para>
</listitem><listitem><para><xref linkend="rbacref-4" /></para>
</listitem>
</itemizedlist>
</sect2><sect2 xml:id="rbac-38"><title>Authorizations and Privileges</title><para>Privileges enforce security policy in the kernel. The difference between
authorizations and privileges concerns the level at which the security policy
is enforced. Without the proper privilege, a process can be prevented from
performing privileged operations by the kernel. Without the proper authorizations,
a user might be prevented from using a privileged application or from performing
security-sensitive operations within a privileged application. For a fuller
discussion of privileges, see <xref linkend="prbac-2" />.</para>
</sect2><sect2 xml:id="rbac-30"><title>Privileged Applications and RBAC</title><para>Applications and commands that can override system controls are considered
privileged applications. Security attributes such as <literal>UID=0</literal>,
privileges, and authorizations make an application privileged.</para><sect3 xml:id="rbac-35"><title>Applications That Check UIDs and GIDs</title><para><indexterm><primary>privileged application</primary><secondary>ID checking</secondary></indexterm><indexterm><primary>security attributes</primary><secondary>checking for</secondary></indexterm>Privileged applications that check for <literal>root</literal> (<literal>UID=0</literal>) or some other special UID or GID have long existed in the
UNIX environment. The  rights profile mechanism enables you to isolate commands
that require a specific ID. Instead of changing the ID on a command that anyone
can access, you can place the command with execution security attributes in
a rights profile. A user or role with that rights profile can then run the
program without having to become superuser.</para><para><indexterm><primary>security attributes</primary><secondary>special ID on commands</secondary></indexterm>IDs can be specified as real or effective.
Assigning effective IDs is preferred over assigning real IDs. Effective IDs
are equivalent to the <command>setuid</command> feature in the file permission
bits. Effective IDs also identify the UID for auditing. However, because some
shell scripts and programs require a real UID of <literal>root</literal>,
real UIDs can be set as well. For example, the <command>pkgadd</command> command
requires a real rather than an effective UID. If an effective ID is not sufficient
to run a command, you need to change the ID to a real ID. For the procedure,
 see <xref linkend="rbactask-24" />.</para>
</sect3><sect3 xml:id="rbac-21"><title>Applications That Check for Privileges</title><para><indexterm><primary>privileged application</primary><secondary>privilege checking</secondary></indexterm><indexterm><primary>privilege checking</primary><secondary>in applications</secondary></indexterm><indexterm><primary>security attributes</primary><secondary>privileges on commands</secondary></indexterm>Privileged
applications can check for the use of privileges. The RBAC rights profile
mechanism enables you to specify the privileges for specific commands. Instead
of requiring superuser capabilities to use an application or command, you
can isolate the command with execution security attributes in a rights profile.
A user or role with that rights profile can then run the command with just
the privileges that the command requires to succeed.</para><itemizedlist><para><indexterm><primary>commands</primary><secondary>that check for privileges</secondary></indexterm>Commands that check for privileges include the following:</para><listitem><para>Kerberos commands, such as <command>kadmin</command>, <command>kprop</command>, and <command>kdb5_util</command></para>
</listitem><listitem><para>Network commands, such as <command>ifconfig</command>, <command>routeadm</command>, and <command>snoop</command></para>
</listitem><listitem><para>File and file system commands, such as <command>chmod</command>, <command>chgrp</command>, and <command>mount</command></para>
</listitem><listitem><para>Commands that control processes, such as <command>kill</command>, <command>pcred</command>, and <command>rcapadm</command></para>
</listitem>
</itemizedlist><para>To add commands with privileges to a rights profile, see <xref linkend="rbactask-24" />.
To determine what commands check for privileges in a particular profile, see <xref linkend="privtask-20" />.</para>
</sect3><sect3 xml:id="rbac-36"><title>Applications That Check Authorizations</title><itemizedlist><para><indexterm><primary>privileged application</primary><secondary>authorization checking</secondary></indexterm><indexterm><primary>authorizations (RBAC)</primary><secondary>checking in privileged application</secondary></indexterm>The Solaris OS additionally
provides commands that check authorizations. By definition, the <literal>root</literal> user
has all authorizations. Therefore, the <literal>root</literal> user can run
any application. Applications that check for authorizations include the following:</para><listitem><para>The entire Solaris Management Console suite of tools</para>
</listitem><listitem><para>Audit administration commands, such as <command>auditconfig</command> and <command>auditreduce</command></para>
</listitem><listitem><para>Printer administration commands, such as <command>lpadmin</command> and <command>lpfilter</command></para>
</listitem><listitem><para>The batch job-related commands, such as <command>at</command>, <command>atq</command>, <command>batch</command>, and <command>crontab</command></para>
</listitem><listitem><para>Device-oriented commands, such as <command>allocate</command>, <command>deallocate</command>, <command>list_devices</command>, and <command>cdrw</command>.</para>
</listitem>
</itemizedlist><para>To test a script or program for authorizations, see <xref linkend="rbactask-12" />. To write a program
that requires authorizations, see <olink targetdoc="gssapipg" targetptr="priv-14" remap="external"><citetitle remap="section">About Authorizations</citetitle> in <citetitle remap="book">Solaris Security for Developers Guide</citetitle></olink>.</para>
</sect3>
</sect2><sect2 xml:id="rbac-33"><title>RBAC Rights Profiles</title><indexterm><primary>rights profiles</primary><secondary>description</secondary>
</indexterm><indexterm><primary>RBAC</primary><secondary>rights profiles</secondary>
</indexterm><para>A <emphasis>rights profile</emphasis> is a collection of system overrides
that can be assigned to a role or user. A rights profile can include authorizations,
commands with assigned security attributes, and other rights profiles. Rights
profile information is split between the <literal>prof_attr</literal> and <literal>exec_attr</literal> databases. The rights profile name and authorizations
are in the <literal>prof_attr</literal> database. The rights profile name
and the commands with assigned security attributes are in the <literal>exec_attr</literal> database.</para><itemizedlist><para>For more information on rights profiles, see the following sections:</para><listitem><para><xref linkend="rbacref-26" /></para>
</listitem><listitem><para><xref linkend="rbacref-12" /></para>
</listitem><listitem><para><xref linkend="rbacref-13" /></para>
</listitem>
</itemizedlist>
</sect2><sect2 xml:id="rbac-31"><title>RBAC Roles</title><indexterm><primary>roles</primary><secondary>description</secondary>
</indexterm><para>A <emphasis>role</emphasis> is a special type of user account from which
you can run privileged applications. Roles are created in the same general
manner as user accounts. Roles have a home directory, a group assignment,
a password, and so on. Rights profiles and authorizations give the role administrative
capabilities. Roles cannot inherit capabilities from other roles or other
users. Discrete roles parcel out superuser capabilities, and thus enable more
secure administrative practices.</para><itemizedlist><para>When a user assumes a role, the role's attributes replace all user attributes.
Role information is stored in the <literal>passwd</literal>, <literal>shadow</literal>,
and <literal>user_attr</literal> databases. Role information can be added
to the <literal>audit_user</literal> database. For detailed information on
setting up roles, see the following sections:</para><listitem><para><xref linkend="rbactask-16" /></para>
</listitem><listitem><para><olink targetptr="rbactask-22" remap="internal">How to Create a Role From the
Command Line</olink></para>
</listitem><listitem><para><olink targetptr="rbactask-23" remap="internal">How to Change the Properties
of a Role</olink></para>
</listitem>
</itemizedlist><para>A role can be assigned to more than one user. All users who can assume
the same role have the same role home directory, operate in the same environment,
and have access to the same files. Users can assume roles from the command
line by running the <command>su</command> command and supplying the role name
and password. Users can also assume a role in the Solaris Management Console
tool.</para><para><indexterm><primary>roles</primary><secondary>assuming after login</secondary></indexterm><indexterm><primary><literal>root</literal> user</primary><secondary>replacing in RBAC</secondary></indexterm><indexterm><primary>superuser</primary><secondary>eliminating in RBAC</secondary></indexterm>A role cannot
log in directly. A user logs in, and then assumes a role. Having assumed a
role, the user cannot assume another role without first exiting their current
role. Having exited the role, the user can then assume another role.</para><para>You can prevent anonymous <literal>root</literal> login by changing
the <literal>root</literal> user into a role, as shown in  <xref linkend="rbactask-20" />.  If the
profile shell command, <command>pfexec</command>, is being audited, the audit
trail contains the login user's real UID, the roles that the user has assumed,
and the actions that the role performed. To audit the system or a particular
user for role operations, see <olink targetptr="rbactask-34" remap="internal">How to Audit
Roles</olink>.</para><para>No predefined roles are shipped with Solaris software. However, the
rights profiles that ship with the software are designed to map to roles.
For example, the Primary Administrator rights profile can be used to create
the Primary Administrator role.</para><itemizedlist><listitem><para>To configure the Primary Administrator role, see <olink targetdoc="group-sa" targetptr="smcover-95" remap="external"><citetitle remap="section">Using the Solaris Management Tools With RBAC (Task Map)</citetitle> in <citetitle remap="book">System Administration Guide: Basic Administration</citetitle></olink>.</para>
</listitem><listitem><para>To configure other roles, see <olink targetptr="rbactask-32" remap="internal">How
to Create and Assign a Role by Using the GUI</olink>.</para>
</listitem><listitem><para>To create roles on the command line, see <xref linkend="rbactask-10" />.</para>
</listitem>
</itemizedlist>
</sect2><sect2 xml:id="rbac-37"><title>Profile Shell in RBAC</title><indexterm><primary>RBAC</primary><secondary>profile shells</secondary>
</indexterm><indexterm><primary>profile shells</primary><secondary>description</secondary>
</indexterm><indexterm><primary>shell</primary><secondary>privileged versions</secondary>
</indexterm><indexterm><primary>Bourne shell</primary><secondary>privileged version</secondary>
</indexterm><indexterm><primary>Korn shell</primary><secondary>privileged version</secondary>
</indexterm><indexterm><primary sortas="C1s">C shell</primary><secondary>privileged version</secondary>
</indexterm><indexterm><primary><command>sh</command> command</primary><secondary>privileged version</secondary>
</indexterm><indexterm><primary><command>csh</command> command</primary><secondary>privileged version</secondary>
</indexterm><indexterm><primary><command>ksh</command> command</primary><secondary>privileged version</secondary>
</indexterm><indexterm><primary><command>pfsh</command> command</primary><secondary>description</secondary>
</indexterm><indexterm><primary><command>pfcsh</command> command</primary><secondary>description</secondary>
</indexterm><indexterm><primary><command>pfksh</command> command</primary><secondary>description</secondary>
</indexterm><indexterm><primary>roles</primary><secondary>assuming in a terminal window</secondary>
</indexterm><para>Roles can run privileged applications from the Solaris Management Console
launcher or from a <emphasis>profile shell</emphasis>. A profile shell is
a special shell that recognizes the security attributes that are included
in a rights profile. Profile shells are launched when the user runs the <command>su</command> command to assume a role. The profile shells are <command>pfsh</command>, <command>pfcsh</command>, and <command>pfksh</command>. The shells  correspond to Bourne
shell (<command>sh</command>), C shell (<command>csh</command>), and Korn
shell (<command>ksh</command>), respectively.</para><para>Users who have been directly assigned a rights profile must invoke a
profile shell to run the commands with security attributes. For usability
and security considerations, see <olink targetptr="rbac-10" remap="internal">Security Considerations
When Directly Assigning Security Attributes</olink>.</para><para>All commands that are executed in a profile shell can be audited. For
more information, see <xref linkend="rbactask-34" />.</para>
</sect2><sect2 xml:id="rbac-34"><title>Name Service Scope and RBAC</title><para><indexterm><primary>name services</primary><secondary>scope and RBAC</secondary></indexterm><indexterm><primary>scope (RBAC)</primary><secondary>description</secondary></indexterm>Name service scope is an important concept for understanding RBAC.
The scope of a role might be limited to an individual host. Alternatively,
the scope might include all hosts that are served by a name service such as
NIS, NIS+, or LDAP. The name service scope for a system is specified in the
file <filename>/etc/nsswitch.conf</filename>. A lookup stops at the first
match. For example, if a rights profile exists in two name service scopes,
only the entries in the first name service scope are used. If <literal>files</literal> is
the first match, then the scope of the role is limited to the local host.</para>
</sect2><sect2 xml:id="rbac-10"><title>Security Considerations When Directly
Assigning Security Attributes</title><indexterm><primary>security attributes</primary><secondary>considerations when directly assigning</secondary>
</indexterm><para>Typically, a user obtains administrative capabilities through a role.
Authorizations and privileged commands are grouped into a rights profile.
The rights profile is included in a role, and the role is assigned to a user.</para><itemizedlist><para>Direct assignment of rights profiles and security attributes is also
possible:</para><listitem><para>Rights profiles, privileges, and authorizations can be assigned
directly to users.</para>
</listitem><listitem><para>Privileges and authorizations can be assigned directly to
roles.</para>
</listitem>
</itemizedlist><para>However, direct assignment is not a secure practice. Users and roles
with a directly assigned privilege could override security policy wherever
this privilege is required by the kernel. When a privilege is a security attribute
of a command in a  rights profile, that privilege is available only for that
command by someone who has that rights profile. The privilege is not available
for other commands that the user or role might run.</para><para>Since authorizations act at the user level, direct assignment of authorizations
can be less dangerous than direct assignment of privileges. However, authorizations
can enable a user to perform highly secure tasks, such as delegate device
administration.</para><para>A rights profile that is assigned directly to a user presents usability
problems more than security problems. The commands with security attributes
in the rights profile can only succeed in a profile shell. The user must open
a profile shell, then type the commands. A role that is assigned a rights
profile gets a profile shell automatically. Therefore, the commands succeed
in the role's shell.</para><para>Rights profiles provide an extensible, clean way to group security characteristics
for particular administrative tasks.</para>
</sect2>
</sect1><sect1 xml:id="prbac-2"><title>Privileges (Overview)</title><indexterm><primary>new features</primary><secondary>privileges</secondary>
</indexterm><indexterm><primary>new features</primary><secondary>process rights management</secondary>
</indexterm><indexterm><primary>superuser</primary><secondary>compared to privilege model</secondary>
</indexterm><indexterm><primary>privileges</primary><secondary>compared to superuser model</secondary>
</indexterm><indexterm><primary>system security</primary><secondary>privileges</secondary>
</indexterm><para>Process rights management enables processes to be restricted at the
command, user, role, or system level. The Solaris OS implements process rights
management through <emphasis>privileges</emphasis>. Privileges decrease the
security risk that is associated with one user or one process having full
superuser capabilities on a system. Privileges and RBAC provide a compelling
alternative model to the traditional superuser model.</para><itemizedlist><listitem><para>For information on RBAC, see <olink targetptr="rbac-1" remap="internal">Role-Based
Access Control (Overview)</olink>.</para>
</listitem><listitem><para>For information on how to administer privileges, see <xref linkend="privtask-1" />.</para>
</listitem><listitem><para>For reference information on privileges, see <xref linkend="privref-1" />.</para>
</listitem>
</itemizedlist><sect2 xml:id="prbac-10"><title>Privileges Protect Kernel Processes</title><para><indexterm><primary>privileges</primary><secondary>protecting kernel processes</secondary></indexterm>A privilege is a discrete right that a process
requires to perform an operation. The right is enforced in the kernel. A program
that operates within the bounds of the Solaris <firstterm>basic set</firstterm> of
privileges operates within the bounds of the system security policy. <command>setuid</command> programs are examples of programs that operate outside the bounds
of the system security policy. By using privileges, programs eliminate the
need for calls to <command>setuid</command>.</para><para>Privileges discretely enumerate the kinds of operations that are possible
on a system. Programs can be run with the exact privileges that enable the
program to succeed. For example, a program that sets the date and writes the
date to an administrative file might require the <constant>file_dac_write</constant> and <constant>sys_time</constant> privileges. This capability eliminates the need to run
any program as <literal>root</literal>.</para><para>Historically, systems have not followed the privilege model. Rather,
systems used the superuser model.  In the superuser model, processes run as <literal>root</literal> or as a user. User processes were limited to acting on the
user's directories and files. <literal>root</literal> processes could create
directories and files anywhere on the system. A process that required creation
of a directory outside the user's directory would run with a <literal>UID=0</literal>,
that is, as <literal>root</literal>. Security policy relied on DAC, discretionary
access control, to protect system files. Device nodes were protected by DAC.
For example, devices owned by group <literal>sys</literal> could be opened
only by members of group <literal>sys</literal>.</para><para>However, <command>setuid</command> programs, file permissions, and administrative
accounts are vulnerable to misuse. The actions that a <command>setuid</command> process
is permitted are more numerous than the process requires to complete its operation.
A <command>setuid</command> program can be compromised by an intruder who
then runs as the all-powerful <literal>root</literal> user. Similarly, any
user with access to the <literal>root</literal> password can compromise the
entire system.</para><para>In contrast, a system that enforces policy with privileges allows a
gradation between user capabilities and <literal>root</literal> capabilities.
A user can be granted privileges to perform activities that are beyond the
capabilities of ordinary users, and <literal>root</literal> can be limited
to fewer privileges than <literal>root</literal> currently possesses. With
RBAC, a command that runs with privileges can be isolated in a rights profile
and assigned to one user or role. <xref linkend="rbac-tbl-7" /> summarizes the gradation between user capabilities and root capabilities
that the RBAC plus privileges model provides.</para><para>The privilege model provides greater security than the superuser model.
Privileges that have been removed from a process cannot be exploited. Process
privileges prevent a program or administrative account from gaining access
to all capabilities. Process privileges can provide an additional safeguard
for sensitive files, where DAC protections alone can be exploited to gain
access.</para><para><indexterm><primary>principle of least privilege</primary></indexterm><indexterm><primary>least privilege</primary><secondary>principle of</secondary></indexterm>Privileges, then, can restrict programs and processes to just
the capabilities that the program requires. This capability is called the <firstterm>principle of least privilege</firstterm>. On a system that implements least
privilege, an intruder who captures a process has access to only those privileges
that the process has. The rest of the system cannot be compromised.</para>
</sect2><sect2 xml:id="prbac-14"><title>Privilege Descriptions</title><para><indexterm><primary>privileges</primary><secondary>categories</secondary></indexterm><indexterm><primary>privileges</primary><secondary>description</secondary></indexterm>Privileges are logically grouped on the basis of the area of the
privilege.</para><itemizedlist><listitem><para><indexterm><primary>files</primary><secondary>privileges relating to</secondary></indexterm><indexterm><primary><literal>FILE</literal> privileges</primary></indexterm><literal>FILE</literal> <emphasis role="strong">privileges &ndash;</emphasis> Privileges
that begin with the string <literal>file</literal> operate on file system
objects. For example, the <constant>file_dac_write</constant> privilege overrides
discretionary access control when writing to files.</para>
</listitem><listitem><para><indexterm><primary>System V IPC</primary><secondary>privileges</secondary></indexterm><indexterm><primary><literal>IPC</literal> privileges</primary></indexterm><literal>IPC</literal> <emphasis role="strong">privileges &ndash;</emphasis> Privileges
that begin with the string <literal>ipc</literal> override IPC object access
controls. For example, the <constant>ipc_dac_read</constant> privilege enables
a process to read remote shared memory that is protected by DAC.</para>
</listitem><listitem><para><indexterm><primary>network</primary><secondary>privileges relating to</secondary></indexterm><indexterm><primary><literal>NET</literal> privileges</primary></indexterm><literal>NET</literal> <emphasis role="strong">privileges &ndash;</emphasis> Privileges that begin with the string <literal>net</literal> give
access to specific network functionality. For example, the <constant>net_rawaccess</constant> privilege enables a device to connect to the network.</para>
</listitem><listitem><para><indexterm><primary>process privileges</primary></indexterm><indexterm><primary><literal>PROC</literal> privileges</primary></indexterm><literal>PROC</literal> <emphasis role="strong">privileges &ndash;</emphasis> Privileges that begin with the
string <literal>proc</literal> allow processes to modify restricted properties
of the process itself. <literal>PROC</literal> privileges include privileges
that have a very limited effect. For example, the <constant>proc_clock_highres</constant> privilege
enables a process to use high resolution timers.</para>
</listitem><listitem><para><indexterm><primary>system properties</primary><secondary>privileges relating to</secondary></indexterm><indexterm><primary><literal>SYS</literal> privileges</primary></indexterm><literal>SYS</literal> <emphasis role="strong">privileges &ndash;</emphasis> Privileges that begin with the string <literal>sys</literal> give
processes unrestricted access to various system properties. For example, the <constant>sys_linkdir</constant> privilege enables a process to make and break hard
links to directories.</para>
</listitem>
</itemizedlist><para>Some privileges have a limited effect on the system, and some have a
broad effect. The definition of the <constant>proc_taskid</constant> privilege
indicates its limited effect:</para><screen>proc_taskid
        Allows a process to assign a new task ID to the calling process.</screen><para>The definition of the <constant>file_setid</constant> privilege indicates
its broad effect:</para><screen>net_rawaccess
        Allow a process to have direct access to  the  network layer.</screen><para><indexterm><primary><filename>privileges</filename> file</primary><secondary>description</secondary></indexterm>The <citerefentry><refentrytitle>privileges</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page provides descriptions
of every privilege. The command <command>ppriv -lv</command> prints a description
of every privilege to standard out.</para>
</sect2><sect2 xml:id="prbac-16"><title>Administrative Differences on a System
With Privileges</title><para><indexterm><primary>superuser</primary><secondary>differences from privilege model</secondary></indexterm><indexterm><primary>privileges</primary><secondary>differences from superuser model</secondary></indexterm><indexterm><primary>administering</primary><secondary>without privileges</secondary></indexterm>A system that has privileges
has several visible differences from a system that does not have privileges.
The following table lists some of the differences.</para><table frame="topbot" pgwide="1" xml:id="prbac-tbl-1"><title>Visible Differences
Between a System With Privileges and a System Without Privileges</title><tgroup cols="3" colsep="0" rowsep="0"><colspec colname="colspec0" colwidth="13.80*"/><colspec colname="colspec1" colwidth="33.39*"/><colspec colname="colspec2" colwidth="51.81*"/><thead><row rowsep="1"><entry><para>Feature</para>
</entry><entry><para>No Privileges</para>
</entry><entry><para>Privileges</para>
</entry>
</row>
</thead><tbody><row><entry><para>Daemons</para>
</entry><entry><para>Daemons run as <literal>root</literal>.</para>
</entry><entry><para><indexterm><primary>daemons</primary><secondary>running with privileges</secondary></indexterm>Daemons run as the user <literal>daemon</literal>.</para><para>For example, the following daemons have been assigned appropriate privileges
and run as <literal>daemon</literal>: <command>lockd</command>, <command>mountd</command>, <command>nfsd</command>, and <command>rpcbind</command>.</para>
</entry>
</row><row><entry><para>Log File Ownership</para>
</entry><entry><para>Log files are owned by <literal>root</literal>.</para>
</entry><entry><para>Log files are now owned by <literal>daemon</literal>, who created the
log file. The <literal>root</literal> user does not own the file.</para>
</entry>
</row><row><entry><para>Error Messages</para>
</entry><entry><para>Error messages refer to superuser.</para><para>For example, <computeroutput>chroot: not superuser</computeroutput>.</para>
</entry><entry><para>Error messages reflect the use of privileges.</para><para>For example, the equivalent error message for <command>chroot</command> failure
is <computeroutput>chroot: exec failed</computeroutput>.</para>
</entry>
</row><row><entry><para><command>setuid</command> Programs</para>
</entry><entry><para>Programs use <command>setuid</command> to complete tasks that ordinary
users are not allowed to perform.</para>
</entry><entry><para>Many <command>setuid</command> programs have been changed to run with
privileges.</para><para>For example, the following utilities use privileges: <command>ufsdump</command>, <command>ufsrestore</command>, <command>rsh</command>, <command>rlogin</command>, <command>rcp</command>, <command>rdist</command>, <command>ping</command>, <command>traceroute</command>, and <command>newtask</command>.</para>
</entry>
</row><row><entry><para>File Permissions</para>
</entry><entry><para>Device permissions are controlled by DAC. For example, members of the
group <literal>sys</literal> can open <filename>/dev/ip</filename>.</para>
</entry><entry><para>File permissions (DAC) do not predict who can open a device. Devices
are protected with DAC <emphasis>and</emphasis> device policy.</para><para>For example, the <filename>/dev/ip</filename> file has <literal>666</literal> permissions,
but the device can only be opened by a process with the appropriate privileges.
Raw sockets are still protected by DAC.</para>
</entry>
</row><row><entry><para>Audit Events</para>
</entry><entry><para>Auditing the use of the <command>su</command> command covers many administrative
functions.</para>
</entry><entry><para>Auditing the use of privileges covers most administrative functions.
The <literal>pm</literal> and <literal>as</literal> audit classes include
audit events that configure device policy and audit events that set privileges.</para>
</entry>
</row><row><entry><para>Processes</para>
</entry><entry><para>Processes are protected by who owns the process.</para>
</entry><entry><para>Processes are protected by privileges. Process privileges and process
flags are visible as a new entry in the <filename>/proc/&lt;pid&gt;</filename> directory, <filename>priv</filename>.</para>
</entry>
</row><row><entry><para>Debugging</para>
</entry><entry><para>No reference to privileges in core dumps.</para>
</entry><entry><para>The ELF note section of core dumps includes information about process
privileges and flags in the <literal>NT_PRPRIV</literal> and <literal>NT_PRPRIVINFO</literal> notes.</para><para>The <command>ppriv</command> utility and other utilities show the proper
number of properly sized sets. The utilities correctly map the bits in the
bit sets to privilege names.</para>
</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2><sect2 xml:id="prbac-24"><title>Privileges and System Resources</title><indexterm><primary>privileges</primary><secondary><constant>PRIV_PROC_LOCK_MEMORY</constant></secondary>
</indexterm><indexterm><primary><constant>PRIV_PROC_LOCK_MEMORY</constant> privilege</primary>
</indexterm><indexterm><primary>resource controls</primary><secondary>privileges, and</secondary>
</indexterm><indexterm><primary>resource controls</primary><secondary><constant>project.max-locked-memory</constant></secondary>
</indexterm><indexterm><primary>resource controls</primary><secondary><constant>zone.max-locked-memory</constant></secondary>
</indexterm><indexterm><primary><constant>project.max-locked-memory</constant> resource control</primary>
</indexterm><indexterm><primary><constant>zone.max-locked-memory</constant> resource control</primary>
</indexterm><para>In the Solaris Express Community Edition,
the <constant>project.max-locked-memory</constant> and <constant>zone.max-locked-memory</constant> resource controls can be used to limit the memory consumption
of processes that are assigned the <constant>PRIV_PROC_LOCK_MEMORY</constant> privilege.
This privilege allows a process to lock pages in physical memory.</para><para>If you assign the <constant>PRIV_PROC_LOCK_MEMORY</constant> privilege
to a rights profile, you can give the processes that have this privilege the
ability to lock all memory. As a safeguard, set a resource control to prevent
the user of the privilege from locking all memory. For privileged processes
that run in a non-global zone, set the <constant>zone.max-locked-memory</constant> resource
control. For privileged processes that run on a system, create a project and
set the <constant>project.max-locked-memory</constant> resource control. For
information about these resource controls, see <olink targetdoc="group-sa" targetptr="rmctrls-1" remap="external">Chapter 6, <citetitle remap="chapter">Resource Controls (Overview),</citetitle> in <citetitle remap="book">System Administration Guide:  Virtualization Using the Solaris Operating System</citetitle></olink> and <olink targetdoc="group-sa" targetptr="z.config.ov-1" remap="external">Chapter 17, <citetitle remap="chapter">Non-Global Zone Configuration (Overview),</citetitle> in <citetitle remap="book">System Administration Guide:  Virtualization Using the Solaris Operating System</citetitle></olink>.</para>
</sect2><sect2 xml:id="prbac-17"><title>How Privileges Are Implemented</title><para><indexterm><primary>privileges</primary><secondary>implemented in sets</secondary></indexterm>Every process has four sets of privileges that determine whether
a process can use a particular privilege. The kernel automatically calculates
the <firstterm>effective set</firstterm> of privileges. You can modify the
initial <firstterm>inheritable set</firstterm> of privileges. A program that
is coded to use privileges can reduce the program's <firstterm>permitted set</firstterm> of
privileges. You can shrink the <firstterm>limit set</firstterm> of privileges.</para><itemizedlist><listitem><para><indexterm><primary>effective privilege set</primary></indexterm><indexterm><primary>privilege sets</primary><secondary>effective</secondary></indexterm><emphasis role="strong">Effective  privilege set, or E &ndash;</emphasis> Is
the set of privileges that is currently in effect. A process can add privileges
that are in the permitted set to the effective set. A process can also remove
privileges from E.</para>
</listitem><listitem><para><indexterm><primary>permitted privilege set</primary></indexterm><indexterm><primary>privilege sets</primary><secondary>permitted</secondary></indexterm><emphasis role="strong">Permitted  privilege set, or P &ndash;</emphasis> Is
the set of privileges that is available for use. Privileges can be available
to a program from inheritance or through assignment. An execution profile
is one way to assign privileges to a program. The <command>setuid</command> command
assigns all privileges that <literal>root</literal> has to a program. Privileges
can be removed from the permitted set, but privileges cannot be added to the
set. Privileges that are removed from P are automatically removed from E.</para><para><indexterm><primary>programs</primary><secondary>privilege-aware</secondary></indexterm>A <firstterm>privilege-aware</firstterm> program removes the privileges
that a program never uses from the program's permitted set. In this way, unnecessary
privileges cannot be exploited by the program or a malicious process. For
more information on privilege-aware programs, see <olink targetdoc="gssapipg" targetptr="ch3priv-18281" remap="external">Chapter 2, <citetitle remap="chapter">Developing Privileged Applications,</citetitle> in <citetitle remap="book">Solaris Security for Developers Guide</citetitle></olink>.</para>
</listitem><listitem><para><indexterm><primary>inheritable privilege set</primary></indexterm><indexterm><primary>privilege sets</primary><secondary>inheritable</secondary></indexterm><emphasis role="strong">Inheritable  privilege set, or I &ndash;</emphasis> Is
the set of privileges that a process can inherit across a call to <command>exec</command>.
After the call to <command>exec</command>, the permitted and the effective
sets are equal, except in the special case of a <command>setuid</command> program.</para><para>For a <command>setuid</command> program, after the call to <command>exec</command>, the inheritable set is first restricted by the limit set.
Then, the set of privileges that were inherited (I), minus any privileges
that were in the limit set (L), are assigned to P and E for that process.</para>
</listitem><listitem><para><indexterm><primary>limit privilege set</primary></indexterm><indexterm><primary>privilege sets</primary><secondary>limit</secondary></indexterm><emphasis role="strong">Limit  privilege set, or L &ndash;</emphasis> Is the outside
limit of what privileges are available to a process and its children. By default,
the limit set is all privileges. Processes can shrink the limit set but can
never extend the limit set. L is used to restrict I. Consequently, L restricts
P and E at the time of <command>exec</command>.</para><para>If a user has
been assigned a profile that includes a program that has been assigned privileges,
the user can usually run that program. On an unmodified system, the program's
assigned privileges are within the user's limit set. The privileges that have
been assigned to the program become part of the user's permitted set. To run
the program that has been assigned privileges, the user must run the program
from a profile shell.</para>
</listitem>
</itemizedlist><para><indexterm><primary>basic privilege set</primary></indexterm><indexterm><primary>privilege sets</primary><secondary>basic</secondary></indexterm><indexterm><primary>users</primary><secondary>initial inheritable privileges</secondary></indexterm>The kernel recognizes a <emphasis>basic privilege set</emphasis>.
On an unmodified system, each user's initial inheritable set equals the basic
set at login. You can modify the user's initial inheritable set. You cannot
modify the basic set.</para><para><indexterm><primary>users</primary><secondary>basic privilege set</secondary></indexterm><indexterm><primary>logging in</primary><secondary>users' basic privilege set</secondary></indexterm><indexterm><primary>privilege sets</primary><secondary>listing</secondary></indexterm>On an unmodified system, a user's
privilege sets at login would appear similar to the following:</para><screen>E (Effective): basic
I (Inheritable): basic
P (Permitted): basic
L (Limit): all</screen><para>Therefore, at login, all users have the basic set in their inheritable
set, their permitted set, and their effective set. A user's limit set contains
all privileges. To put more privileges in the user's effective set, you must
assign a rights profile to the user. The rights profile would include commands
to which you have added privileges. You can also assign privileges directly
to the user or role, though such privilege assignment can be risky. For a
discussion of the risks, see <olink targetptr="rbac-10" remap="internal">Security Considerations
When Directly Assigning Security Attributes</olink>.</para>
</sect2><sect2 xml:id="prbac-19"><title>How Processes Get Privileges</title><para><indexterm><primary>privileges</primary><secondary>inherited by processes</secondary></indexterm><indexterm><primary>obtaining</primary><secondary>privileges</secondary></indexterm>Processes can inherit privileges. Or, processes can be assigned
privileges. A process inherits privileges from its parent process. At login,
the user's initial inheritable set of privileges determines what privileges
are available to the user's processes. All child processes of the user's initial
login inherit that set.</para><para><indexterm><primary>privileges</primary><secondary>processes with assigned privileges</secondary></indexterm>You can also directly assign privileges
to programs, users, and roles. When a program requires privileges, you assign
the privileges to the program's executable in a rights profile. Users or roles
that are permitted to run the program are assigned the profile that includes
the program. At login or when a profile shell is entered, the program runs
with privilege when the program's executable is typed in the profile shell.
For example, a role that includes the Object Access Management profile is
able to run the <command>chmod</command> command with the <constant>file_chown</constant> privilege.</para><para>When a role or user runs a program that has been directly assigned an
additional privilege, the assigned privilege is added to the role or user's
inheritable set. Child processes of the program that was assigned privileges
inherit the privileges of the parent. If the child process requires more privileges
than the parent process, the child process must be directly assigned those
privileges.</para><para><indexterm><primary>privileges</primary><secondary>programs aware of privileges</secondary></indexterm><indexterm><primary>programs</primary><secondary>privilege-aware</secondary></indexterm>Programs that are coded
to use privileges are called privilege-aware programs. A privilege-aware program
turns on the use of privilege and turns off the use of privilege during program
execution. To succeed in a production environment, the program must be assigned
the privileges that the program turns on and off.</para><para>For examples of privilege-aware code, see <olink targetdoc="gssapipg" targetptr="ch3priv-18281" remap="external">Chapter 2, <citetitle remap="chapter">Developing Privileged Applications,</citetitle> in <citetitle remap="book">Solaris Security for Developers Guide</citetitle></olink>. To assign privileges to a program
that requires privileges, see <olink targetptr="privtask-7" remap="internal">How to Add Privileges
to a Command</olink>.</para>
</sect2><sect2 xml:id="prbac-21"><title>Assigning Privileges</title><para><indexterm><primary>privileges</primary><secondary>assigning to a command</secondary></indexterm><indexterm><primary>commands</primary><secondary>that assign privileges</secondary></indexterm><indexterm><primary>obtaining</primary><secondary>privileges</secondary></indexterm>You, in your capacity as system administrator, are
responsible for assigning privileges. Typically, you assign the privilege
to a command in a rights profile. The rights profile is then assigned to a
role or to a user. The Solaris Management Console provides the graphical user
interface (GUI) to assign privileges. Privileges can also be assigned by using
commands such as <command>smuser</command> and <command>smrole</command>.
For more information on how to use the GUI to assign privileges, see <xref linkend="rbactask-1" />.</para>
<para>
<indexterm><primary>privileges</primary><secondary>assigning to a user</secondary></indexterm>
Privileges can also be assigned directly to a user. If you trust
a subset of users to use a privilege responsibly throughout their sessions,
you can assign the privilege directly. Good candidates for direct assignment
are privileges that have a limited effect, such as <constant>proc_clock_highres</constant>.
Poor candidates for direct assignment are privileges that have far-reaching
effects, such as <constant>file_dac_write</constant>.</para><para>Privileges can also be denied to a user or to a system. Care must be
taken when removing privileges from the initial inheritable set or the limit
set of a user or a system.</para><sect3 xml:id="prbac-11"><title>Expanding a User or Role's Privileges</title><para>Users and roles have an inheritable set of privileges, and a limit set
of privileges. The limit set cannot be expanded, since the limit set is initially
all privileges. The initial inheritable set can be expanded for users, roles,
and systems. A privilege that is not in the inheritable set can also be assigned
to a process.</para><para>The assignment of privileges per process is the most precise way to
add privileges. You can expand the number of privileged operations that a
user can perform by enabling the user to assume a role. The role would be
assigned profiles that include commands with added privileges. When the user
assumes the role, the user gets the role's profile shell. By typing in the
role's shell, the commands in the role's profiles execute with the added privileges.</para><para><indexterm><primary>privileges</primary><secondary>executing commands with privilege</secondary></indexterm>You can also assign a profile to the
user rather than to a role that the user assumes. The profile would include
commands with added privileges. When the user opens a profile shell, such
as <command>pfksh</command>, the user can execute the commands in the user's
profile with privilege. In a regular shell, the commands do not execute with
privilege. The privileged process can only execute in a privileged shell.</para><para><indexterm><primary>privilege sets</primary><secondary>adding privileges to</secondary></indexterm>To expand the initial inheritable set of privileges
for users, roles, or systems is a riskier way to assign privileges. All privileges
in the inheritable set are in the permitted and effective sets. All commands
that the user or role types in a shell can use the directly assigned privileges.
Directly assigned privileges enable a user or role to easily perform operations
that can be outside the bounds of their administrative responsiblities.</para><para>When you add to the initial inheritable set of privileges on a system,
all users who log on to the system have a larger set of basic privileges.
Such direct assignment enables all users of the system to easily perform operations
that are probably outside the bounds of ordinary users.</para>
</sect3><sect3 xml:id="prbac-15"><title>Restricting a User or Role's Privileges</title><para><indexterm><primary>privileges</primary><secondary>removing from a user</secondary></indexterm><indexterm><primary>privilege sets</primary><secondary>removing privileges from</secondary></indexterm>By removing privileges, you can prevent
users and roles from performing particular tasks. You can remove privileges
from the initial inheritable set, and from the limit set. You should carefully
test removal of privileges before you distribute an initial inheritable set
or a limit set that is smaller than the default  set. By removing privileges
from the initial inheritable set, you might prevent users from logging in.
When privileges are removed from the limit set, a legacy <command>setuid</command> program
might fail because the program requires a privilege that was removed.</para>
</sect3><sect3 xml:id="prbac-12"><title>Assigning Privileges to a Script</title><para><indexterm><primary>privileges</primary><secondary>assigning to a script</secondary></indexterm><indexterm><primary>scripts</primary><secondary>running with privileges</secondary></indexterm>Scripts are executables, like commands. Therefore,
in a rights profile, you can add privileges to a script just as you can add
privileges to a command. The script runs with the added privileges when a
user or role who has been assigned the profile executes the script in a profile
shell. If the script contains commands that require privileges, the commands
with added privileges should also be in the profile.</para><para>Privilege-aware programs can restrict privileges per process. Your job
with a privilege-aware program is to assign the executable just the privileges
that the program needs. You then test the program to see that the program
succeeds in performing its tasks. You also check that the program does not
abuse its use of privileges.</para>
</sect3>
</sect2><sect2 xml:id="prbac-23"><title>Privileges and Devices</title><indexterm><primary>devices</primary><secondary>privilege model and</secondary>
</indexterm><indexterm><primary>devices</primary><secondary>superuser model and</secondary>
</indexterm><indexterm><primary>privileges</primary><secondary>devices and</secondary>
</indexterm><para>The privilege model uses privileges to protect system interfaces that
are protected by file permissions alone in the superuser model. In a system
with privileges, file permissions are too weak to protect the interfaces.
A privilege such as <constant>proc_owner</constant> could override file permissions
and then give full access to all of the system.</para><para>Therefore, ownership of the device directory is not sufficient to open
a device. For example, members of the group <literal>sys</literal> are no
longer automatically allowed to open the <filename>/dev/ip</filename> device.
The file permissions on <filename>/dev/ip</filename> are <literal>0666</literal>,
but the <constant>net_rawaccess</constant> privilege is required to open the
device.</para><para>Device policy is controlled by privileges. The <command>getdevpolicy</command> command
displays the device policy for every device. The device configuration command, <command>devfsadm</command>, installs the device policy. The <command>devfsadm</command> command
binds privilege sets with <command>open</command> for reading or writing of
devices. For more information, see the <citerefentry><refentrytitle>getdevpolicy</refentrytitle><manvolnum>1M</manvolnum></citerefentry> and <citerefentry><refentrytitle>devfsadm</refentrytitle><manvolnum>1M</manvolnum></citerefentry> manual pages.</para>
<para>Device policy allows you more flexibility in granting permission to
open devices. You can require different privileges or more privileges than
the default device policy. The privilege requirements can be modified for
the device policy and for the driver proper. You can modify the privileges
when installing, adding, or updating a device driver.</para>
<para>The <command>add_drv</command> and <command>update_drv</command> commands
can modify device policy entries and driver-specific privileges. You must
be running a process with the full set of privileges to change the device
policy. For more information, see the <citerefentry><refentrytitle>add_drv</refentrytitle><manvolnum>1M</manvolnum></citerefentry> and <citerefentry><refentrytitle>update_drv</refentrytitle><manvolnum>1M</manvolnum></citerefentry> manual pages.</para>
</sect2>
<sect2 xml:id="privtask-12">
<title>Privileges and Debugging</title>
<indexterm><primary>privileges</primary><secondary>debugging</secondary></indexterm>
<para>The Solaris OS provides tools to debug privilege failure. The <command>ppriv</command> command
and the <command>truss</command> command provide debugging output. For examples,
see the <citerefentry><refentrytitle>ppriv</refentrytitle><manvolnum>1</manvolnum></citerefentry> man
page. For a procedure, see <olink targetptr="privtask-6" remap="internal">How to Determine
Which Privileges a Program Requires</olink>.</para>
</sect2>
</sect1>
</chapter><?Pub *0000071751 0?>
